# Exercise 1: ex1_publisher_subscriber

## The following ReadMe will explain all the implementation of the package requested form the Exercise 1

___

## 1. Message  

The execution of the exercise is made by using a pre-existing message Structure. In particular it was used a **JointTrajectory Message**. This type of message is made up of a vector string indicating the name of the joints ,and of a vector of **JointTrajectoryPoint Messages**. JointTrajectoryPoints in turn contains other structure to specify some characteristics. Each trajectory point specifies either positions, velocities,accelerations or positions, effort for the trajectory to be executed. In the exercise we will use only the positions vector to specify not trajectories but some positions of the joints .

## 2. Publisher

The file start with the initialization of the node , being called **talker**. Then is defined an NodeHandler which by the use of the function **advertise** will advertise a topic. This call connects to the master to publicize that the node will be publishing messages on the given topic that in this case is **motor_chatter**. Defined that preliminary operations , it's time to build the structure of the publisher and the sctructure of messages which should be sent. A JointTrajectory is istantiated and with it , all the names of the 6 joints that we are considering . After that, are defined and filled the positions vectors for each joint. All the positions are composed by random numbers generated by an srand function. The message is now ready to be sent , but first we use **ROS_INFO_STREAM** to have a better view of the information that we are sending to te subscriber.

The code ends with the publish function that send the message, and with spiOnce and sleep function to process the callback and insert a little delay. All this code is then inserted into a **while (ros::ok())** that will permitt to ciclically send messages.

## 3.Subscriber

The subscriber file is made up of a main and of a function. In the main is defined the Subscriber itself, by using the init (giving the node the name listener), and is also defined the handler of the node. The handler using the function **subscribe** specifies the topic in wich the node is interested (motor_chatter) and specify the function to use for handling incoming messages (**chatterCallback**). The main ends by calling the function **spin** which will made the subscriber node work by entering an avent loop.

In the other part of the file the handling function is specified. This function receive messages from the Publisher and by using **ROS_INFO_STREAM** , these messages are shown in the default stream ( that in our case is the terminal).
